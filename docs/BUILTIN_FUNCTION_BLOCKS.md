# Builtin Function Blocks

## Overview

Builtin function blocks are pre-defined, reusable functions that ship with the RagOmics Agent. They provide common functionality that doesn't need to be regenerated by the LLM each time.

## Purpose

1. **Conversion Functions**: Handle data format conversions between languages (Python ↔ R)
2. **Common Operations**: Frequently used data processing steps
3. **Performance**: Avoid regenerating the same code repeatedly
4. **Reliability**: Well-tested implementations for critical operations

## Directory Structure

```
function_blocks/
└── builtin/
    ├── convert_anndata_to_sc_matrix/
    │   ├── config.json
    │   ├── code.py
    │   └── requirements.txt
    ├── convert_sc_matrix_to_anndata/
    │   ├── config.json
    │   ├── code.py
    │   └── requirements.txt
    ├── convert_seurat_to_sc_matrix/
    │   ├── config.json
    │   ├── code.r
    │   └── requirements.txt
    └── convert_sc_matrix_to_seuratobject/
        ├── config.json
        ├── code.r
        └── requirements.txt
```

## Config.json Format

Each builtin function block requires a `config.json` file:

```json
{
  "name": "convert_anndata_to_sc_matrix",
  "type": "python",
  "description": "Convert AnnData to shared single-cell matrix format",
  "static_config": {
    "args": [],
    "description": "Convert AnnData to SC matrix format for R interoperability",
    "tag": "conversion",
    "input_specification": {
      "required_files": [
        {
          "name": "_node_anndata.h5ad",
          "type": "anndata",
          "description": "AnnData object to convert"
        }
      ]
    },
    "output_specification": {
      "output_files": [
        {
          "name": "_node_sc_matrix",
          "type": "directory",
          "description": "Shared SC matrix format"
        },
        {
          "name": "_node_anndata.h5ad",
          "type": "anndata", 
          "description": "Original AnnData (preserved)"
        }
      ]
    }
  },
  "parameters": {}
}
```

## How Builtin Blocks are Used

### 1. Registration
Builtin blocks are registered when the agent starts:
```python
# In agent initialization
loader = FunctionBlockLoader("function_blocks")
builtin_blocks = loader.load_all_blocks("builtin")
```

### 2. Automatic Selection
The agent can reference builtin blocks:
- During conversion detection
- When the Function Selector agent identifies a match
- As ExistingFunctionBlock references

### 3. Execution
Builtin blocks execute the same way as generated blocks:
```python
executor.execute(builtin_block, path_dict, params)
```

## Current Builtin Blocks

### 1. convert_anndata_to_sc_matrix
- **Type**: Python
- **Purpose**: Convert AnnData → SC Matrix format
- **Input**: `_node_anndata.h5ad`
- **Output**: `_node_sc_matrix/` directory

### 2. convert_sc_matrix_to_anndata  
- **Type**: Python
- **Purpose**: Convert SC Matrix → AnnData
- **Input**: `_node_sc_matrix/` directory
- **Output**: `_node_anndata.h5ad`

### 3. convert_seurat_to_sc_matrix
- **Type**: R
- **Purpose**: Convert SeuratObject → SC Matrix format
- **Input**: `_node_seuratObject.rds`
- **Output**: `_node_sc_matrix/` directory

### 4. convert_sc_matrix_to_seuratobject
- **Type**: R  
- **Purpose**: Convert SC Matrix → SeuratObject
- **Input**: `_node_sc_matrix/` directory
- **Output**: `_node_seuratObject.rds`

## Package Management

### Python Function Blocks
Python function blocks use `requirements.txt` with standard pip package names:
```
scanpy
pandas
numpy
matplotlib
```

### R Function Blocks
**IMPORTANT**: R function blocks DO NOT use `requirements.txt`. Instead, the R executor generates `install_packages.R` from the requirements field in the function block.

R package requirements format:
- **CRAN packages**: Just the package name (e.g., `Seurat`, `ggplot2`)
- **Bioconductor packages**: `Bioconductor::package_name` (e.g., `Bioconductor::SingleCellExperiment`)
- **GitHub packages**: `user/repo` format (e.g., `dynverse/princurve`)

Example R requirements:
```
Seurat
ggplot2
Bioconductor::SingleCellExperiment
Bioconductor::scater
dynverse/princurve
```

The R executor automatically:
1. Installs BiocManager for Bioconductor packages
2. Installs remotes for GitHub packages
3. Generates and runs `install_packages.R` before executing the function block

## Adding New Builtin Blocks

1. Create a new directory under `function_blocks/builtin/`
2. Add the required files:
   - `config.json` - Block metadata
   - `code.py` or `code.r` - Implementation
   - `requirements.txt` - Dependencies (Python only; R uses requirements field in function block)
3. Register in the agent's builtin block list
4. Add tests in `tests/builtin/`

## Benefits

1. **No LLM Cost**: Builtin blocks don't consume API tokens
2. **Consistency**: Same implementation every time
3. **Performance**: No generation latency
4. **Testing**: Can be thoroughly tested offline
5. **Versioning**: Can be updated with the codebase